/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	//ARM GCC INLINE ASSEMBLY CODE
	//usage of ASM or __asm is the same
	//https://luxoft.udemy.com/course/embedded-system-programming-on-arm-cortex-m3m4/learn/lecture/19391686#overview
	//Example 1, sum in assembly
	__asm volatile("LDR R1,=#0x20001000");	//LDR - load register R1 with address 0x20001000
	__asm volatile("LDR R2,=#0x20001004");	//LDR - load register R2 with address 0x20001004
	__asm volatile("LDR R0,[R1]");			//Load R0 with value pointed by R1`s address
	__asm volatile("LDR R1,[R2]");			//Load R1 with value pointed by R2`s address
	__asm volatile("ADD R0,R0,R1");			//ADD at R0 with value pointed by R1`and R2
	__asm volatile("STR R0,[R2]");			//STR - store R0 register at R2 address

	//When brackets [R2] are used, the process control PC is referring to the address of R2, not to the value
	//So when STR to store the value of R0 is used, it needs an address where to store it, it cannot store it in another register.
	//To store the value in another register, we should use LDR, to load the value of R2 with value of R0.


	//Example 2, how to move into register, a value from a C variable
	int val = 9;
	//%0 is the first variable in the :::list of variables, here we have only 1, called "var"
	//"r" is a constraint string, r telling compiler to use general registers
	__asm volatile("MOV R0,%0"::"r"(val));
	//for "i" - immediate value, we need to use values instead of stack variable
		//__asm volatile("MOV R0,%0"::"i"(0x09));


	//Example 3: MRS - move content of Control register to "c" variable control_reg
	uint32_t control_reg;
	__asm volatile("MRS %0, CONTROL":"=r"(control_reg)::);


	//Example 4: copy content from src to dest
	//=r -> write only ; r - read only
	int src = 5, dest=0;
	printf("dest var BEFORE=\t %d\n", dest);
	__asm volatile("MOV %0,%1" : "=r"(dest) : "r"(src));
	printf("dest var AFTER=\t\t %d\n", dest);



	//Example 5: copy contents of a pointer into another variable
	int p1, *p2;
	p2 = (int*)0x20000008;
	__asm volatile("LDR %0,[%1]" : "=r"(p1) : "r"(p2));



	/* Loop forever */
	for(;;);
}
